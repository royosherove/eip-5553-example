---
eip: 5500
title: Simple Works Representation Standard
author: Roy Osherove (@royosherove)
discussions-to: https://github.com/ethereum/EIPs/issues/5500
status: Draft
type: Standards Track
category: ERC
created: 2022-08-11
requires: 20,721
---

## Simple Summary
A standardized way to represent intellectual works on chain, along with a refined royalty representation mechanism and associated metadata. This standard is not associated with a specific type of work and could represent many types of works such as musical works, videos, books, images and more.
The standard is kept very generic on purpose to allow the industry to evolve new ecosystems that can all rely on the same basic standard at their core.

## Abstract
This standard allows market participants to:
1) Observe the canonical on-chain representation of an intellectual work
2) Discover its attached metadata
3) Discover its related royalty rights holders
4) In the future, this will enable building registration, licensing and payout mechanisms for intellectual property assets.

The standard is based on an `ERC721` based contract implementing the new `IWorksRegistration` interface.
The `IWorksRegistration` interface contains:
### royaltyTokens() function
returns an array of addresses related to ERC20 tokens that implement `ERC-5501` - the `IRoyaltyToken` interface standard. These royalty tokens represent a more granular and streamlined way to declare royalty splits for multiple collaboration participants for the creation of the work. For example, for a musical work, we might have two tokens representing the Composition/Writing/Publishing royalty rights side, and the Recording/Master side. 

These royalty tokens are distributed to the collaboration participants and can later be queried for the various holders, for purposes of distribution of roylaties - i.e if you hold 10% of a royalty token, you might get 10% of financial distribution related to that type of royalty.

### metadataURI() function
returns the URI to a metadata file containing any required metadata for the work. Each work type will have its own metadata standard, defined seperately, and is not the focus of this standard. The hope is that the file will be hosted in IPFS or arweave or other resource hash based access systems in which we know the file's contents are not changeable without changing the URI.

### changeMetadataURI() function
Allows changing the URI when updating the metadata for the work. Will also trigger the event `MetadataChanged`

### ledger() function
returns the address of the registery or registrar contract, or an EOA account that initialized the work and associated royalty tokens. A work might be registered in multiple places by different actors for different purposes, and this enables market participants to discover which registery mechanism is the parent of the work and might have special access rights to manage the work.

## Motivation
There is no accepted standard mechanism to license a work, or to represent it, except using tradtianl NFTs. But regular NFTs only represent a collectible item use case, and cannot easily represent more complicated use cases of licensing a work for different types of uses.
Toe enable such mechanisms, we need a more robust mechanism for :
1) Declaring that a work exists, SEPARATE from its purchase ability
2) Declaring possibly multiple interested parties to be paid for such work 

for #1 no standard exists today.
For #2 we only have regular splits standards based on NFT purchases, or through mechanisms like [0xsplits](https://www.0xsplits.xyz/). While these are a great headstart, they do not contain the ability to name multiple types of collaboration participants, and more importantly, do not contain an easy way to manage the splitsin a way that feels natural.

With EIP5500, registration is taken care of, and splits are taken care of by defining the splits as an open array of ERC20 tokens that represent split percentages. Moving splits to various participants will be as simple as sending an ERC20 token from one wallet to another. discovering split movements is as simple as checking ERC20 transfer events.

In the future, we can build full payout mechanisms based on these simple split tokens, and licensing standards on top of those payout mechanisms, which are not possible today due to the complexity of splits management in the traditional web2 world.

## Specification (TBD - ignore anything below this)

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
RFC 2119.

**contracts that want to represent a work on chain MUST implement ERC-721 AND this ERC**

Implementers of this standard **MUST** have all of the following functions:

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.9;
import '@openzeppelin/contracts/interfaces/IERC165.sol';


///
/// @dev Interface for Simple Works Registration Standard
///
interface IWorksRegistration is IERC165 {
    
    /// @notice Called with the new uri to an updated metadata file
    /// @param _newUri - the uri pointing to a metadata file (file standard is up to the implementer)
    /// @param _newFileHash - The hash of the new metadata file, for future reference and verification
    function changeMetadataURI(string memory _newUri, string memory _newFileHash) external ;

    /// @return array of addresess of ERC20 tokens representing royalty interest in the work
    /// @dev i.e implementing ERC5501 (IRoyaltyInterestToken interface)
    function royaltyInterestTokens() external view returns (address[] memory) ;

    /// @return the address of the contract or EOA that initialized the work registration
    /// @dev i.e a registery or registrar, to be implemented in the future
    function ledger() external view returns (address) ;

    /// @return the uri of the current metadata file for the work
    function metadataURI() external view returns (string memory) ;

    /// @dev event to be triggered whenever metadata URI is changed
    /// @param byAddress the addresses that triggered this operation
    /// @param oldURI the uri to the old metadata file prior to the change
    /// @param oldFileHash the hash of the old metadata file prior to the change
    /// @param newURI the uri to the new metadata file 
    /// @param newFileHash the hash of the new metadata file 
    event MetadaDataChanged(address byAddress,string oldURI, string oldFileHash, string newURI, string newFileHash);
}
```

### Examples

This standard being used on an ERC-721 during deployment:

#### Deploying an ERC-721 and signaling support for ERC-2981

```solidity
constructor (string memory name, string memory symbol, string memory baseURI) {
        _name = name;
        _symbol = symbol;
        _setBaseURI(baseURI);
        // register the supported interfaces to conform to ERC721 via ERC165
        _registerInterface(_INTERFACE_ID_ERC721);
        _registerInterface(_INTERFACE_ID_ERC721_METADATA);
        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);
        // Royalties interface
        _registerInterface(_INTERFACE_ID_ERC2981);
    }
```

#### Checking if the NFT being sold on your marketplace implemented royalties

```solidity  
bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;

function checkRoyalties(address _contract) internal returns (bool) {
    (bool success) = IERC165(_contract).supportsInterface(_INTERFACE_ID_ERC2981);
    return success;
 }
```

## Rationale

### Optional royalty payments

It is impossible to know which NFT transfers are the result of sales, and which are merely wallets moving or consolidating their NFTs. Therefore, we cannot force every transfer function, such as `transferFrom()` in ERC-721, to involve a royalty payment as not every transfer is a sale that would require such payment. We believe the NFT marketplace ecosystem will voluntarily implement this royalty payment standard to provide ongoing funding for artists/creators. NFT buyers will assess the royalty payment as a factor when making NFT purchasing decisions.

### Simple royalty payments to a single address

This EIP does not specify the manner of payment to the royalty recipient. Furthermore, it is impossible to fully know and efficiently implement all possible types of royalty payments logic. With that said, it is on the royalty payment receiver to implement all additional complexity and logic for fee splitting, multiple receivers, taxes, accounting, etc. in their own receiving contract or off-chain processes. Attempting to do this as part of this standard, it would dramatically increase the implementation complexity, increase gas costs, and could not possibly cover every potential use-case. This ERC should be considered a minimal, gas-efficient building block for further innovation in NFT royalty payments. Future EIPs can specify more details regarding payment transfer and notification.

### Royalty payment percentage calculation

This EIP mandates a percentage-based royalty fee model. It is likely that the most common case of percentage calculation will be where the `royaltyAmount` is always calculated from the `_salePrice` using a fixed percent i.e. if the royalty fee is 10%, then a 10% royalty fee must apply whether `_salePrice` is 10, 10000 or 1234567890.

As previously mentioned, implementers can get creative with this percentage-based calculation but there are some important caveats to consider. Mainly, ensuring that the `royaltyInfo()` function is not aware of the unit of exchange and that unpredictable variables are avoided in the percentage calculation. To follow up on the earlier `block.timestamp` example, there is some nuance which can be highlighted if the following events ensued:

1. Marketplace sells NFT.
2. Marketplace delays `X` days before invoking `royaltyInfo()` and sending payment.
3. Marketplace receives `Y` for `royaltyAmount` which was significantly different from the `royaltyAmount` amount that would've been calculated `X` days prior if no delay had occurred.
4. Royalty recipient is dissatisfied with the delay from the marketplace and for this reason, they raise a dispute.

Rather than returning a percentage and letting the marketplace calculate the royalty amount based on the sale price, a `royaltyAmount` value is returned so there is no dispute with a marketplace over how much is owed for a given sale price. The royalty fee payer must pay the `royaltyAmount` that `royaltyInfo()` stipulates.

### Unit-less royalty payment across all marketplaces, both on-chain and off-chain

This EIP does not specify a currency or token used for sales and royalty payments. The same percentage-based royalty fee must be paid regardless of what currency, or token was used in the sale, paid in the same currency or token. This applies to sales in any location including on-chain sales, over-the-counter (OTC) sales, and off-chain sales using fiat currency such as at auction houses. As royalty payments are voluntary, entities that respect this EIP must pay no matter where the sale occurred - a sale outside of the blockchain is still a sale. The exact mechanism for paying and notifying the recipient will be defined in future EIPs.

### Universal Royalty Payments

Although designed specifically with NFTs in mind, this standard does not require that a contract implementing EIP-2981 is compatible with either ERC-721 or ERC-1155 standards. Any other contract could use this interface to return royalty payment information, provided that it is able to uniquely identify assets within the constraints of the interface. ERC-2981 is, therefore, a universal royalty standard for many other asset types.

## Backwards Compatibility

This standard is compatible with current ERC-721 and ERC-1155 standards.

## Security Considerations

There are no security considerations related directly to the implementation of this standard.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
