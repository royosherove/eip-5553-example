---
eip: 5500
title: Simple Works & Royalty Interest Representation Standard
author: Roy Osherove (@royosherove)
discussions-to: https://github.com/ethereum/EIPs/issues/5500
status: Draft
type: Standards Track
category: ERC
created: 2022-08-11
requires: 20,721
---

## Simple Summary
A standardized way to represent intellectual works on chain, along with a refined royalty representation mechanism and associated metadata. This standard is not associated with a specific type of work and could represent many types of works such as musical works, videos, books, images and more.
The standard is kept very generic on purpose to allow the industry to evolve new ecosystems that can all rely on the same basic standard at their core.

## Abstract
This standard allows market participants to:
1) Observe the canonical on-chain representation of an intellectual work
2) Discover its attached metadata
3) Discover its related royalty rights holders
4) In the future, this will enable building registration, licensing and payout mechanisms for intellectual property assets.

The standard is based on an `ERC721` based contract implementing the new `IWorksRegistration` interface.
The `IWorksRegistration` interface contains:
### royaltyTokens() function
returns an array of addresses related to ERC20 tokens that implement `ERC-5501` - the `IRoyaltyToken` interface standard. These royalty tokens represent a more granular and streamlined way to declare royalty splits for multiple collaboration participants for the creation of the work. For example, for a musical work, we might have two tokens representing the Composition/Writing/Publishing royalty rights side, and the Recording/Master side. 

These royalty tokens are distributed to the collaboration participants and can later be queried for the various holders, for purposes of distribution of roylaties - i.e if you hold 10% of a royalty token, you might get 10% of financial distribution related to that type of royalty.

### metadataURI() function
returns the URI to a metadata file containing any required metadata for the work. Each work type will have its own metadata standard, defined seperately, and is not the focus of this standard. The hope is that the file will be hosted in IPFS or arweave or other resource hash based access systems in which we know the file's contents are not changeable without changing the URI.

### changeMetadataURI() function
Allows changing the URI when updating the metadata for the work. Will also trigger the event `MetadataChanged`

### ledger() function
returns the address of the registery or registrar contract, or an EOA account that initialized the work and associated royalty tokens. A work might be registered in multiple places by different actors for different purposes, and this enables market participants to discover which registery mechanism is the parent of the work and might have special access rights to manage the work.

## Motivation
There is no accepted standard mechanism to license a work, or to represent it, except using tradtianl NFTs. But regular NFTs only represent a collectible item use case, and cannot easily represent more complicated use cases of licensing a work for different types of uses.
Toe enable such mechanisms, we need a more robust mechanism for :
1) Declaring that a work exists, SEPARATE from its purchase ability
2) Declaring possibly multiple interested parties to be paid for such work 

for #1 no standard exists today.
For #2 we only have regular splits standards based on NFT purchases, or through mechanisms like [0xsplits](https://www.0xsplits.xyz/). While these are a great headstart, they do not contain the ability to name multiple types of collaboration participants, and more importantly, do not contain an easy way to manage the splitsin a way that feels natural.

With EIP5500, registration is taken care of, and splits are taken care of by defining the splits as an open array of ERC20 tokens that represent split percentages. Moving splits to various participants will be as simple as sending an ERC20 token from one wallet to another. discovering split movements is as simple as checking ERC20 transfer events.

In the future, we can build full payout mechanisms based on these simple split tokens, and licensing standards on top of those payout mechanisms, which are not possible today due to the complexity of splits management in the traditional web2 world.

## Specification 

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
RFC 2119.

**contracts that want to represent a work on chain MUST implement ERC-721 AND this ERC**

Implementers of this standard **MUST** have all of the following functions:

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.9;
import '@openzeppelin/contracts/interfaces/IERC165.sol';


///
/// @dev Interface for Simple Works Registration Standard
///
interface IWorksRegistration is IERC165 {
    
    /// @notice Called with the new uri to an updated metadata file
    /// @param _newUri - the uri pointing to a metadata file (file standard is up to the implementer)
    /// @param _newFileHash - The hash of the new metadata file, for future reference and verification
    function changeMetadataURI(string memory _newUri, string memory _newFileHash) external ;

    /// @return array of addresess of ERC20 tokens representing royalty interest in the work
    /// @dev i.e implementing ERC5501 (IRoyaltyInterestToken interface)
    function royaltyInterestTokens() external view returns (address[] memory) ;

    /// @return the address of the contract or EOA that initialized the work registration
    /// @dev i.e a registery or registrar, to be implemented in the future
    function ledger() external view returns (address) ;

    /// @return the uri of the current metadata file for the work
    function metadataURI() external view returns (string memory) ;

    /// @dev event to be triggered whenever metadata URI is changed
    /// @param byAddress the addresses that triggered this operation
    /// @param oldURI the uri to the old metadata file prior to the change
    /// @param oldFileHash the hash of the old metadata file prior to the change
    /// @param newURI the uri to the new metadata file 
    /// @param newFileHash the hash of the new metadata file 
    event MetadaDataChanged(address byAddress,string oldURI, string oldFileHash, string newURI, string newFileHash);
}
```

### Examples 

This standard being used on an ERC-721 during deployment:

#### Implementing a Music Works type based on IWorksRegistration
```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.9;
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import "./interfaces/IWorksRegistration.sol";
import "./interfaces/Structs.sol";


contract SongRegistration is ERC721, IWorksRegistration {
    address public songLedger;
    address public compToken;
    address public recToken;
    string public metadataURI;
    string public fileHash;
    uint256 public tokenId;
    bool public activated =false;

    function supportsInterface(bytes4 interfaceId) public view virtual override( ERC721, IERC165) returns (bool) {
        return
            interfaceId == type(IWorksRegistration).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function getInterfaceId() public pure returns (bytes4){
        return type(IWorksRegistration).interfaceId;
    }

    constructor (
        uint256 _tokenId,
        address _songLedger,
        SongMintingParams memory _params,
        address _compAddress,
        address _recAddress
        )
    ERC721(_params.shortName, _params.symbol){

        songLedger = _songLedger;
        compToken = _compAddress;
        recToken = _recAddress;
        metadataURI = _params.metadataUri;
        fileHash = _params.fileHash;
        tokenId = _tokenId;
        
        _safeMint(_songLedger, _tokenId);
        emit Minted(_params.shortName,_songLedger,_compAddress,_recAddress,_msgSender(),tokenId,_params.metadataUri);
    }

    function changeMetadataURI(string memory _newURI,string memory _newFileHash) public 
     {
        string memory oldURI = metadataURI;
        string memory oldHash = fileHash;
        metadataURI = _newURI; 
        fileHash = _newFileHash;
        
        emit MetadataChanged(oldURI, oldHash,_newURI,_newFileHash);
    }
    
    function royaltyInterestTokens() external view returns (address[] memory) {
        address[] memory items = new address[](2); 
        items[0] = compToken;
        items[1] = recToken;
        return items;
    }
    function ledger() external view returns (address) {
         return songLedger;
    }

    event MetadataChanged(
        string  oldUri, string oldFileHash,
        string  newUri, string newFileHash
        );
    event Minted(
        string  abbvName,
        address ledger,
        address compToken,
        address recToken,
        address creator,
        uint256 tokenId,
        string metadataUri
        );
}



```

#### Deploying a new music works instance using a simple song registry contract

```solidity  
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.9;
import "@openzeppelin/contracts/utils/Counters.sol";
import "./SongRegistration.sol";
import "./CompositionRoyaltyToken.sol";
import "./RecordingRoyaltyToken.sol";


contract SimpleSongLedger is IERC721Receiver {
    using Counters for Counters.Counter;
    Counters.Counter private songIds;
      function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    function mintSong(SongMintingParams memory _params) public {
        CompositionRoyaltyToken comp = new CompositionRoyaltyToken(address(this),"SONGCOMP","COMP");
        RecordingRoyaltyToken rec = new RecordingRoyaltyToken(address(this),"SONGREC","REC");
        songIds.increment();

        SongRegistration newSong = new SongRegistration(
                                        songIds.current(),
                                        address(this),
                                        _params,
                                        address(comp),
                                        address(rec)
                                    );
    }
}


```


### A more robust royalty interest structure

Current royalty implementations deal only with a single type of royalty payments: NFT sales. They also only allow a single type of royalty - i.e you cannot have different royalty interest owners receive royalty based on different licensing types. 
In other words, currently, a royalty split works the same way no matter what type of purchase or licese deal has happened, for all parties involved.

With this ERC, we allow multiple **types** of royalty interests. A classic case is the music industry in which you have writing/composition royalties, and recording/master royalties. Different licensing types will pay different precentages to different parties based on context.

In the case of a song cover, a license paymenht focumla can be created so that that 
a) Original work's writers get paid for using the lyrics or composition of the song
b) recording artists of the original song do not get paid since their recording is not used
c) recording artists of the new work will get paid
d) there are no writing royalties for the creators of the cover.

Moreover, we have single structure that connects to all types of royalty types, and allowes finding them easily.

## Rationale
### A more robust future for licensing
By seperating the canonical version of the work from its various licensed uses (NFT purchase, streaming, usage of art etc..) we are allowing a new ecosystem of various license types and payment types for a single work, based on the same standard.

### A single pointer to the works metadata
The work points to metadata housed in IPFS or arweave and allows changing it and keeping track of the changes in a simple and standard way. Today the only metadata standard is NFT metadata extension, but we do not know which standard the document adheres to. With different work types we can focumlate different metadata standards for different work types and have a simple easy place to do discover atached metadata.

### Allowing people from creative industries to put their work on chain

We foresee new marketplaces that allow registering your work, all base don the IWOrksRegistration standard, but implemented for different types of works: Books, video, music and more. These marketplaces will support familiar royalty interest use cases, with the added benefits of transparent, fast and permissionless web3 infrastructure.

## Security Considerations

There are no security considerations related directly to the implementation of this standard.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
